#include <algorithm>
#include <cstdlib>
#include <functional>
#include <iostream>
#include <vector>
using namespace std;

class X {
 public:
    int m_x;

    X() {
        m_x = 0;
        cout << "构造函数被调用" << endl;
    }

    X(const X& temx) {
        m_x = temx.m_x;
        cout << "拷贝构造函数被调用" << endl;
    }

    ~X() {
        cout << "析构函数被调用" << endl;
    }

    X(int value)
        : m_x(value)  //类型转换构造函数
    {
        cout << "类型转换构造函数" << endl;
    }
};

int main(void) {
    //

    X x10(1000);
    cout << "---------------------------------" << endl;

    X x11 = 1111;  //隐式类型转换，调用类型转换构造函数
    cout << "---------------------------------" << endl;

    X x12 = X(1212);
    cout << "---------------------------------" << endl;

    X x13 = (X)1313;
    system("pause");
    return 0;
}
/*
* (1)程序转化语义
类型转换构造函数
------------------------
类型转换构造函数
------------------------
类型转换构造函数
------------------------
类型转换构造函数

结果：全部调用类型转换构造函数，视频演示vs2017是全部调用构造函数
	在linux平台上，不优化的时候，x11，x12，x13是调用拷贝构造函数。第一种x10写法效率最高。
*
* 总结：当编译器面临用一个类对象作为另一个类对象初值的情况，各个编译器表现不同，但是所以编译器都是为了提高效率。
*	我们也没有办法确定编译器是一定调用拷贝构造函数。
*
*问题：拷贝构造函数是否必须有：
*不一定，视情况而定。如果类中只有一些简单的类型，编译器内部支持成员变量的bitwise copy。
*
*/
